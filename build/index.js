// Generated by CoffeeScript 1.9.3
'use strict';
var API, bs, cache, changed, config, debug, debugModule, entries, generateType, getConfig, groupedTasks, gulp, gulpIf, handleError, handleInsert, insert, loadPlugins, loadPluginsConfig, mergeStream, notifier, notify, ordersByTask, packageJsonPath, path, plumber, rename, requireDir, runSequence, sourcemaps, standardConfigTypeChecker, tasks, tasksByOrder, through, typeCheck, typeCheckErr, typeCheckerTypes,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

require('source-map-support').install();

gulp = require('gulp');

runSequence = require('run-sequence');

through = require('through2');

gulpIf = require('gulp-if');

mergeStream = require('merge-stream');

sourcemaps = require('gulp-sourcemaps');

changed = require('gulp-changed');

rename = require('gulp-rename');

insert = require('gulp-insert');

plumber = require('gulp-plumber');

typeCheck = require('type-check').typeCheck;

debugModule = require('debug');

bs = require('browser-sync').create();

notifier = require('node-notifier');

requireDir = require('require-dir');

path = require('path');

loadPlugins = require('load-plugins');

entries = require('object.entries');

config = require('rc')('pavios');

debug = debugModule('Pavios');

debug('Starting...');

getConfig = function(taskName) {
  return config.tasks[taskName];
};

cache = [];

notify = function(msg, arg) {
  var index, logMsg, ref, title;
  ref = arg != null ? arg : {}, title = ref.title, logMsg = ref.logMsg;
  index = null;
  if (indexOf.call(cache, msg) < 0) {
    cache.push(msg);
    index = cache.indexOf(msg);
    if ((logMsg != null) && (msg == null)) {
      msg = 'See terminal for more information';
    }
    notifier.notify({
      title: title || 'Pavios',
      message: msg
    });
    if (logMsg != null) {
      if (logMsg instanceof Error) {
        console.log('\u0007');
        console.log(logMsg.stack || logMsg.message);
      } else {
        console.log(logMsg);
      }
    }
    return setTimeout((function() {
      return cache.splice(index, 1);
    }), 1500);
  }
};

notify.taskFinished = function(taskName) {
  return notify(taskName + " task finished successfully.", {
    title: taskName
  });
};

handleError = function(taskName) {
  var handler;
  if (taskName == null) {
    taskName = '?';
  }
  handler = function(err) {
    notify("Error in task " + taskName + ", see terminal for more info", {
      title: taskName,
      logMsg: err.stack != null ? err.stack.slice(0, 2500) : err
    });
    return this.emit('end');
  };
  return plumber.bind(plumber, handler);
};

typeCheckerTypes = {
  minify: 'Boolean',
  sourcemaps: 'Boolean',
  renameTo: 'String | Function | Object',
  insert: '{ prepend: Maybe String, append: Maybe String, wrap: Maybe (String, String) }',
  compilerOpts: 'Object',
  standardOpts: function() {
    return "{ minify: Maybe " + this.minify + ", sourcemaps: Maybe " + this.sourcemaps + ", insert: Maybe " + this.insert + ", renameTo: Maybe " + this.renameTo + ", compilerOpts: Maybe " + this.compilerOpts + " }";
  }
};

typeCheckerTypes.standardOpts = typeCheckerTypes.standardOpts();

typeCheckErr = function(taskName) {
  return console.error("The configuration for the " + taskName + " task is in the wrong format. See the config guide for more information: https://github.com/rioc0719/pavios/README.md#config-guide");
};

standardConfigTypeChecker = function(config, taskName, optsType) {
  var typeCheckPattern;
  if (optsType == null) {
    optsType = 'Object';
  }
  typeCheckPattern = "[{ src: String, dest: String, opts: Maybe " + optsType + " }]";
  if (!typeCheck(typeCheckPattern, config)) {
    typeCheckErr(taskName);
    return false;
  }
  return true;
};

generateType = function(types) {
  var generatedType, i, len, localDebug, punctuation, type;
  localDebug = debugModule('Pavios:generateType');
  localDebug('Generating these types: ', types);
  generatedType = '{';
  types = types.filter(function(type) {
    return typeCheckerTypes[type] != null;
  });
  for (i = 0, len = types.length; i < len; i++) {
    type = types[i];
    localDebug('Adding type ', type);
    punctuation = types.indexOf(type) === types.length - 1 ? '' : ',';
    generatedType += "\n\t" + type + ": Maybe " + typeCheckerTypes[type] + punctuation;
  }
  generatedType += '\n}';
  localDebug('Final generated type: ', generatedType);
  return generatedType;
};

handleInsert = function(obj) {
  var localDebug;
  localDebug = debugModule('Pavios:insert');
  if (obj == null) {
    localDebug('null passed as argument, returning empty stream');
    return through.obj();
  }
  localDebug('obj is ', obj);
  if (typeof obj.prepend === 'string') {
    localDebug('Prepending ', obj.prepend);
    return insert.prepend(obj.prepend);
  }
  if (typeof obj.append === 'string') {
    localDebug('Appending ', obj.append);
    return insert.append(obj.append);
  }
  if (typeCheck('(String, String)', obj.wrap)) {
    localDebug("Wrapping in " + obj.wrap[0] + " and " + obj.wrap[1]);
    return insert.wrap(obj.wrap[0], obj.wrap[1]);
  }
};

API = {
  notify: notify,
  merge: mergeStream,
  $: {
    "if": gulpIf,
    browserSync: bs,
    sourcemaps: sourcemaps,
    changed: changed,
    rename: rename,
    insert: handleInsert
  },
  reload: bs.stream,
  handleError: handleError,
  typeCheck: {
    raw: typeCheck,
    standard: standardConfigTypeChecker,
    types: typeCheckerTypes,
    generateType: generateType,
    typeCheckErr: typeCheckErr
  },
  debug: debugModule
};

module.exports = {
  getConfig: getConfig,
  gulp: gulp,
  API: API
};

packageJsonPath = path.join(path.dirname(module.parent.filename), 'package.json');

loadPluginsConfig = {
  config: require(packageJsonPath),
  strip: 'pavios-',
  camelize: false
};

tasks = new Map(entries(loadPlugins('pavios-*', loadPluginsConfig)));

debug('tasks: ', tasks);

tasksByOrder = new Map;

tasks.forEach(function(fn, task) {
  return tasksByOrder.set(task, fn.order);
});

ordersByTask = new Map;

tasksByOrder.forEach(function(order, task) {
  var currTasks;
  if (ordersByTask.has(order)) {
    currTasks = ordersByTask.get(order) || [];
    return ordersByTask.set(order, currTasks.concat([task]));
  } else {
    return ordersByTask.set(order, [task]);
  }
});

groupedTasks = [];

ordersByTask.forEach(function(tasksList, order) {
  if (tasksList.length > 1) {
    return groupedTasks[order] = slice.call(tasksList);
  } else if (tasksList.length === 1) {
    return groupedTasks[order] = tasksList[0];
  }
});

groupedTasks = groupedTasks.filter(function(x) {
  return x != null;
});

debug('groupedTasks:', groupedTasks);

gulp.task('watch', function() {
  var fn, localDebug;
  localDebug = debugModule('Pavios:watch');
  fn = function(task, event) {
    return localDebug("File " + event.path + " was " + event.type + ", running " + task);
  };
  return tasks.forEach(function(arg, task) {
    var sources, watcher;
    sources = arg.sources;
    if (sources != null) {
      if (!typeCheck('[String]', sources)) {
        localDebug("Type check on " + (JSON.stringify(sources)) + " for " + task + " failed");
        console.error("Can't watch files for the \"" + task + "\" task because the config is invalid.");
        return;
      }
      localDebug("Watching srcs " + sources + ", running " + task + " on change");
      watcher = gulp.watch(sources, [task]);
      return watcher.on('change', fn.bind(null, task));
    }
  });
});

groupedTasks.push('watch');

gulp.task('default', runSequence.apply(null, groupedTasks));

//# sourceMappingURL=index.js.map
